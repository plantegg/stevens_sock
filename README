This is a standalone version of Richard Stevens' "sock" program, based
on the code available for the UNIX Network Programming book, at:

  http://www.kohala.com/start/unpv12e.html

I found this version at

  http://ttcplinux.sourceforge.net/tools/tools.html

and cleaned up the tarball a bit. To make sock a little easier to
find, I'm now hosting it on a dedicated webpage:

  http://www.icir.org/christian/sock.html

I will implement minor updates to the code when I feel they make sense
for reasons of clarity or educational value, but I won't make any other
changes (such as additional features or similars).

I'm happy to incorporate build fixes where feasible and necessary, but
I do not give build support etc.

						Enjoy,
						Christian

sock 编译

安装 automake

修改configure ，去掉版本限制：

```
ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}

AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}  //去掉这个版本限制
```

configure 完后将 configure.in 重命名为configure.ac ，然后执行make



https://www.icir.org/christian/sock.html 对应下载地址：https://www.icir.org/christian/downloads/sock-0.3.2.tar.gz

example

```
// -O 9000 端口listen 后过 9 秒再 accept，这样有机会看到三次握手完成，但是在服务端全连接队里被填满
// -T SO_REUSEPORT 可以冲用 time_wait/FIN_WAIT2 端口
// -F fork 支持多个客户端
// -K 启用 keepalive ，但是默认 net.ipv4.tcp_keepalive_time 为 7200，需要自己改小后快速触发 keepalive 包
sock -q 1 -F -v -T -O 9000 -P 5000 -Q 3000 -i  -s 100.81.131.221 4321
```



Help

```
#sock
usage: sock [ options ] <host> <port>              (for client; default)
       sock [ options ] -s [ <IPaddr> ] <port>     (for server)
       sock [ options ] -i <host> <port>           (for "source" client)
       sock [ options ] -i -s [ <IPaddr> ] <port>  (for "sink" server)
options: -b n  bind n as client's local port number
         -c    convert newline to CR/LF & vice versa
         -f a.b.c.d.p  foreign IP address = a.b.c.d, foreign port# = p
         -g a.b.c.d  loose source route
         -h    issue TCP half close on standard input EOF
         -i    "source" data to socket, "sink" data from socket (w/-s)
         -j a.b.c.d  join multicast group
         -k    write or writev in chunks
         -l a.b.c.d.p  client's local IP address = a.b.c.d, local port# = p
         -n n  #buffers to write for "source" client (default 1024)
         -o    do NOT connect UDP client
         -p n  #ms to pause before each read or write (source/sink)
         -q n  size of listen queue for TCP server (default 5)
         -r n  #bytes per read() for "sink" server (default 1024)
         -s    operate as server instead of client
         -t n  set multicast ttl
         -u    use UDP instead of TCP
         -v    verbose
         -w n  #bytes per write() for "source" client (default 1024)
         -x n  #ms for SO_RCVTIMEO (receive timeout)
         -y n  #ms for SO_SNDTIMEO (send timeout)
         -A    SO_REUSEADDR option
         -B    SO_BROADCAST option
         -C    set terminal to cbreak mode
         -D    SO_DEBUG option
         -E    IP_RECVDSTADDR option
         -F    fork after connection accepted (TCP concurrent server)
         -G a.b.c.d  strict source route
         -H n  IP_TOS option (16=min del, 8=max thru, 4=max rel, 2=min$)
         -I    SIGIO signal
         -J n  IP_TTL option
         -K    SO_KEEPALIVE option
         -L n  SO_LINGER option, n = linger time
         -N    TCP_NODELAY option
         -O n  #ms to pause after listen, but before first accept
         -P n  #ms to pause before first read or write (source/sink)
         -Q n  #ms to pause after receiving FIN, but before close
         -R n  SO_RCVBUF option
         -S n  SO_SNDBUF option
         -T    SO_REUSEPORT option
         -U n  enter urgent mode before write number n (source only)
         -V    use writev() instead of write(); enables -k too
         -W    ignore write errors for sink client
         -X n  TCP_MAXSEG option (set MSS)
         -Y    SO_DONTROUTE option
         -Z    MSG_PEEK

```
